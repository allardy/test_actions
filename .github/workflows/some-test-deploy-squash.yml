name: Trigger Production Deploy Squash

on:
  workflow_dispatch:

jobs:
  merge-master-to-prod:
    name: Squash Master into Prod
    runs-on: ubuntu-latest

    permissions:
      contents: write
      actions: write

    steps:
      - name: Checkout prod branch
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          ref: prod
          token: ${{ secrets.SECRET }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Fetch all branches & tags
        run: |
          git fetch --prune --unshallow || true
          git fetch --tags
          git fetch origin master prod

      - name: Determine commit range for deploy
        id: range
        run: |
          # We'll use a tag called "prod-latest" to mark the last master commit we already deployed
          TAG_NAME="prod-latest"

          # If prod-latest doesn't exist yet, default to the very first commit on master
          if git rev-parse -q --verify "origin/${TAG_NAME}" >/dev/null; then
            START_REF="origin/${TAG_NAME}"
          else
            echo "prod-latest tag not found; using first commit on master"
            START_REF="$(git rev-list --max-parents=0 origin/master | tail -n1)"
          fi

          # Count commits in START_REF..origin/master
          COMMIT_COUNT="$(git rev-list "${START_REF}"..origin/master --count)"
          FIRST_COMMIT="$(git rev-list "${START_REF}"..origin/master | tail -n1 | cut -c1-7)"
          LAST_COMMIT="$(git rev-list "${START_REF}"..origin/master | head -n1 | cut -c1-7)"

          # Output them so we can re-use below
          echo "commit_count=${COMMIT_COUNT}" >> $GITHUB_OUTPUT
          echo "first_commit=${FIRST_COMMIT}" >> $GITHUB_OUTPUT
          echo "last_commit=${LAST_COMMIT}" >> $GITHUB_OUTPUT

      - name: Squash changes from master into prod
        run: |
          # Check out prod branch
          git checkout prod

          # Merge (squash) everything from origin/master, preferring "theirs" on conflict
          git merge --squash origin/master -Xtheirs

          # Build the commit message
          cat <<EOF > /tmp/commitmsg
          Production Deploy: ${COMMIT_COUNT} commits (${FIRST_COMMIT} â†’ ${LAST_COMMIT})

          Included commits:
          EOF
          # Append a one-line summary for each commit
          git log HEAD..origin/master --pretty=format:"- %h %s" >> /tmp/commitmsg

          # Create the single squash commit
          git commit -F /tmp/commitmsg

      - name: Push new squash commit to prod
        run: |
          git push origin prod --force-with-lease

      - name: Update the prod-latest tag on master
        run: |
          # Tag the HEAD of origin/master as the new "prod-latest".
          # So next time, we know exactly up to which commit we've deployed.
          TAG_NAME="prod-latest"
          git checkout master
          git merge --ff-only origin/master
          git tag -f "${TAG_NAME}"
          git push origin "refs/tags/${TAG_NAME}" --force
